"use client"

import type React from "react"

import { useState, useRef, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { Card, CardContent } from "@/components/ui/card"
import { Textarea } from "@/components/ui/textarea"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Mic, MicOff, Send, RefreshCw, Volume2, Lightbulb } from "lucide-react"
import { getAIResponse, type ConversationMode, translateWithJapanese, suggestNextPhrases } from "@/lib/ai-service"
import { useTranslation } from "@/hooks/useTranslation"
import en from "@/lib/locales/en.json"
import { Accordion, AccordionItem, AccordionTrigger, AccordionContent } from "@/components/ui/accordion"

type Message = {
  role: "user" | "assistant"
  content: string
}

// localStorageé€²æ—ãƒ‡ãƒ¼ã‚¿æ›´æ–°ç”¨
function updateProgress({ minutes, score }: { minutes: number; score: number }) {
  if (typeof window === "undefined") return;
  const STORAGE_KEY = "progressData";
  const raw = localStorage.getItem(STORAGE_KEY);
  let data = {
    weekly: [
      { day: "Mon", minutes: 0, score: 0 },
      { day: "Tue", minutes: 0, score: 0 },
      { day: "Wed", minutes: 0, score: 0 },
      { day: "Thu", minutes: 0, score: 0 },
      { day: "Fri", minutes: 0, score: 0 },
      { day: "Sat", minutes: 0, score: 0 },
      { day: "Sun", minutes: 0, score: 0 },
    ],
    skills: [
      { skill: "Pronunciation", score: 0 },
      { skill: "Fluency", score: 0 },
      { skill: "Vocabulary", score: 0 },
      { skill: "Grammar", score: 0 },
    ],
  };
  if (raw) {
    try {
      data = JSON.parse(raw);
    } catch {}
  }
  // ä»Šæ—¥ã®æ›œæ—¥ã«åŠ ç®—
  const now = new Date();
  const dayIdx = now.getDay() === 0 ? 6 : now.getDay() - 1; // æœˆæ›œ=0, æ—¥æ›œ=6
  data.weekly[dayIdx].minutes += minutes;
  data.weekly[dayIdx].score = Math.max(data.weekly[dayIdx].score, score); // æœ€é«˜ã‚¹ã‚³ã‚¢ã‚’è¨˜éŒ²
  // skillsã‚‚ä»®ã§å…¨ã¦åŠ ç®—
  data.skills.forEach(s => { s.score = Math.max(s.score, score); });
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}

export default function PracticePage() {
  const [messages, setMessages] = useState<Message[]>([])
  const [input, setInput] = useState("")
  const [isRecording, setIsRecording] = useState(false)
  const [scenario, setScenario] = useState("free")
  const [isLoading, setIsLoading] = useState(false)
  const [showTranslation, setShowTranslation] = useState(false)
  const [suggestedPhrases, setSuggestedPhrases] = useState("")
  const [isSpeaking, setIsSpeaking] = useState(false)
  const [currentSpeech, setCurrentSpeech] = useState("")

  const messagesEndRef = useRef<HTMLDivElement>(null)
  const recognitionRef = useRef<any>(null)
  const suggestTimerRef = useRef<NodeJS.Timeout | null>(null)

  const t = useTranslation()

  // åˆæœŸAIãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«è¨³ã‚’ä»˜ä¸ã—ã€éŸ³å£°ã‚‚1å›ã ã‘å³åº§ã«å†ç”Ÿ
  useEffect(() => {
    let isMounted = true;
    (async () => {
      // è‹±èªï¼‹è¨³ã§åˆæœŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚»ãƒƒãƒˆ
      const aiMsg = en.ai_greeting;
      const aiMsgWithTranslation = await translateWithJapanese(aiMsg);
      if (isMounted) {
        setMessages([{ role: "assistant", content: aiMsgWithTranslation }]);
        if (typeof window !== 'undefined' && 'speechSynthesis' in window) {
          window.speechSynthesis.cancel();
          const utter = new window.SpeechSynthesisUtterance(aiMsg);
          utter.lang = "en-US";
          window.speechSynthesis.speak(utter);
        }
      }
    })();
    return () => { isMounted = false; };
  }, [t]);

  // Scroll to bottom of messages
  useEffect(() => {
    // å°‘ã—ä½™ç™½ã‚’æŒãŸã›ã¦ä¸‹ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth", block: "end" });
    // window.scrollBy(0, -40); // å¿…è¦ãªã‚‰å¾®èª¿æ•´
  }, [messages])

  // ãƒšãƒ¼ã‚¸ãƒã‚¦ãƒ³ãƒˆæ™‚ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’æœ€ä¸Šéƒ¨ã«
  useEffect(() => {
    window.scrollTo(0, 0)
  }, [])

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒAIè¿”ç­”å¾Œ5ç§’é–“å…¥åŠ›ã—ãªã‘ã‚Œã°ãƒ•ãƒ¬ãƒ¼ã‚ºææ¡ˆ
  useEffect(() => {
    if (messages.length === 0) return;
    const lastMsg = messages[messages.length - 1];
    if (lastMsg.role !== "assistant") return;
    if (isLoading) return;
    setSuggestedPhrases("");
    if (suggestTimerRef.current) clearTimeout(suggestTimerRef.current);
    suggestTimerRef.current = setTimeout(async () => {
      if (input.trim() === "") {
        const phrases = await suggestNextPhrases(messages, scenario);
        setSuggestedPhrases(phrases);
      }
    }, 5000);
    return () => {
      if (suggestTimerRef.current) clearTimeout(suggestTimerRef.current);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [messages, scenario, isLoading]);

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå…¥åŠ›ã‚’å§‹ã‚ãŸã‚‰ææ¡ˆãƒ•ãƒ¬ãƒ¼ã‚ºã‚’éè¡¨ç¤º
  useEffect(() => {
    if (input.trim() !== "") {
      setSuggestedPhrases("");
      if (suggestTimerRef.current) clearTimeout(suggestTimerRef.current);
    }
  }, [input]);

  // Mock function to simulate AI response
  const handleSendMessage = async (overrideInput?: string, isFromVoiceRecognition: boolean = false) => {
    const messageToSend = overrideInput !== undefined ? overrideInput : input.trim()
    if (!messageToSend) return
    setInput("")
    setIsLoading(true)

    try {
      // éŸ³å£°èªè­˜ã‹ã‚‰ã®å ´åˆã¯æ—¢ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¿½åŠ ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€é‡è¤‡ã—ãªã„
      if (!isFromVoiceRecognition) {
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™ºè©±ï¼ˆè‹±èªï¼‹è¨³ï¼‰ã‚’è¿½åŠ 
        const userWithTranslation = await translateWithJapanese(messageToSend)
        setMessages((prev) => [...prev, { role: "user", content: userWithTranslation }])
      }

      const response = await getAIResponse(messageToSend, scenario as ConversationMode, messages)
      setMessages((prev) => [...prev, { role: "assistant", content: response.message }])
      // é€²æ—ãƒ‡ãƒ¼ã‚¿ã‚’ä»®ã§æ›´æ–°ï¼ˆä¾‹: 5åˆ†ãƒ»ã‚¹ã‚³ã‚¢3~5ã®ãƒ©ãƒ³ãƒ€ãƒ ï¼‰
      updateProgress({ minutes: 5, score: Math.floor(Math.random() * 3) + 3 });
      // AIè¿”ç­”ã‚’è‡ªå‹•ã§èª­ã¿ä¸Šã’
      if (typeof window !== 'undefined' && 'speechSynthesis' in window) {
        // è‹±èªéƒ¨åˆ†ã®ã¿ã‚’æŠ½å‡ºã—ã¦èª­ã¿ä¸Šã’
        const lines = response.message.split(/\n+/);
        const englishText = lines[0] || "";
        
        const utter = new window.SpeechSynthesisUtterance(englishText);
        utter.lang = "en-US";
        
        // éŸ³å£°èª­ã¿ä¸Šã’çŠ¶æ…‹ã‚’æ›´æ–°
        setIsSpeaking(true);
        setCurrentSpeech(englishText);
        
        // èª­ã¿ä¸Šã’é–‹å§‹æ™‚ã®ãƒ­ã‚°
        console.log("AIéŸ³å£°èª­ã¿ä¸Šã’é–‹å§‹:", englishText);
        
        // èª­ã¿ä¸Šã’å®Œäº†ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç›£è¦–
        utter.onend = () => {
          console.log("AIéŸ³å£°èª­ã¿ä¸Šã’å®Œäº†");
          setIsSpeaking(false);
          setCurrentSpeech("");
        };
        
        // ã‚¨ãƒ©ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç›£è¦–
        utter.onerror = (e) => {
          console.error("AIéŸ³å£°èª­ã¿ä¸Šã’ã‚¨ãƒ©ãƒ¼:", e);
          setIsSpeaking(false);
          setCurrentSpeech("");
        };
        
        window.speechSynthesis.speak(utter);
      }
    } catch (error) {
      console.error("Error:", error)
      setMessages((prev) => [
        ...prev,
        { role: "assistant", content: "I apologize, but I'm having trouble connecting right now. Please try again later." },
      ])
    } finally {
      setIsLoading(false)
    }
  }

  // éŸ³å£°èªè­˜ã®é–‹å§‹ãƒ»åœæ­¢ï¼ˆWeb Speech APIï¼‰
  const toggleRecording = async () => {
    if (!isRecording) {
      // éŒ²éŸ³é–‹å§‹
      const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition
      if (!SpeechRecognition) {
        setMessages((prev) => [
          ...prev,
          { role: "assistant", content: "ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯éŸ³å£°èªè­˜ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚" },
        ])
        return
      }
      const recognition = new SpeechRecognition()
      recognitionRef.current = recognition
      recognition.lang = "en-US"
      recognition.interimResults = false
      recognition.maxAlternatives = 1

      recognition.onresult = async (event: any) => {
        // ã™ã¹ã¦ã®å€™è£œã‚’çµåˆã—ã€éƒ¨åˆ†çš„ãªå˜èªã‚„ãƒ•ãƒ¬ãƒ¼ã‚ºã‚‚æœ€å¤§é™æŠ½å‡º
        let transcript = "";
        for (let i = 0; i < event.results.length; i++) {
          transcript += event.results[i][0].transcript + " ";
        }
        transcript = transcript.trim();

        // èªè­˜ã—ãŸéŸ³å£°ãŒå­˜åœ¨ã™ã‚‹å ´åˆ
        if (transcript) {
          console.log("èªè­˜ã•ã‚ŒãŸéŸ³å£°: ", transcript);
          
          // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ä¿®æ­£ï¼šè‹±èªãŒå«ã¾ã‚Œãªã„å ´åˆã‚‚ã€ãã®ã¾ã¾è‹±èªã¨ã—ã¦æ‰±ã†
          // å‰å‡¦ç†ï¼šæ–‡é ­ã‚’å¤§æ–‡å­—ã«ã—ã€æœ€å¾Œã«ãƒ”ãƒªã‚ªãƒ‰ãŒãªã‘ã‚Œã°è¿½åŠ 
          transcript = transcript.charAt(0).toUpperCase() + transcript.slice(1);
          if (!transcript.endsWith('.') && !transcript.endsWith('?') && !transcript.endsWith('!')) {
            transcript += '.';
          }
          
          // éŸ³å£°èªè­˜ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›æ¬„ã«ã‚»ãƒƒãƒˆ
          setInput(transcript);
          
          try {
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™ºè©±ã‚’è¿½åŠ ã—ã¦ã‹ã‚‰ã€AIã«é€ä¿¡
            const userWithTranslation = await translateWithJapanese(transcript);
            setMessages((prev) => [...prev, { role: "user", content: userWithTranslation }]);
            
            // éŸ³å£°èªè­˜ã‹ã‚‰ã®ãƒ•ãƒ©ã‚°ã‚’trueã«ã—ã¦ã€é‡è¤‡è¡¨ç¤ºã‚’é˜²ã
            handleSendMessage(transcript, true);
          } catch (error) {
            console.error("ç¿»è¨³å‡¦ç†ã‚¨ãƒ©ãƒ¼:", error);
            // ç¿»è¨³ã«å¤±æ•—ã—ãŸå ´åˆã§ã‚‚ã€èªè­˜ã—ãŸãƒ†ã‚­ã‚¹ãƒˆã ã‘ã¯è¡¨ç¤ºã™ã‚‹
            setMessages((prev) => [...prev, { role: "user", content: transcript }]);
            handleSendMessage(transcript, true);
          }
        } else {
          // å®Œå…¨ã«ç„¡éŸ³ã ã£ãŸå ´åˆã®ã¿ã€ŒCould you say that again?ã€ã¨è¿”ã™
          setMessages((prev) => [
            ...prev,
            { role: "assistant", content: "Could you say that again?\nã‚‚ã†ä¸€åº¦è¨€ã£ã¦ã„ãŸã ã‘ã¾ã™ã‹ï¼Ÿ" }
          ]);
        }
        setIsRecording(false);
      }
      recognition.onerror = (event: any) => {
        setMessages((prev) => [
          ...prev,
          { role: "assistant", content: "éŸ³å£°èªè­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚" },
        ])
        setIsRecording(false)
      }
      recognition.onend = () => {
        setIsRecording(false)
      }

      recognition.start()
      setIsRecording(true)
    } else {
      // éŒ²éŸ³åœæ­¢
      recognitionRef.current?.stop()
      setIsRecording(false)
    }
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault()
      handleSendMessage()
    }
  }

  // ãƒ•ãƒ¬ãƒ¼ã‚ºé›†ã®å¤šè¨€èªãƒ‡ãƒ¼ã‚¿
  const phraseSet = t('phrase_set') || {};

  return (
    <div className="bg-background min-h-screen m-0 p-0">
      <div className="container px-0 py-0 mx-auto mt-8 lg:ml-[300px]">
        {/* ä½¿ã„æ–¹ã‚¬ã‚¤ãƒ‰ã‚’ç”»é¢å³ä¸Šã«å›ºå®šè¡¨ç¤ºï¼ˆå¸¸ã«è¡¨ç¤ºï¼‰ */}
        <div className="block fixed top-12 right-4 z-50 w-[250px]">
          <div className="border border-blue-300 bg-blue-50 rounded-lg p-4 shadow-sm w-full">
            <div className="font-bold text-blue-700 mb-2 flex items-center gap-2">
              <span role='img' aria-label='info'>â„¹ï¸</span> {t('how_to_use_title')}
            </div>
            <div className="text-sm whitespace-pre-line text-blue-900">{t('how_to_use_body')}</div>
          </div>
        </div>

        <div className="flex w-full" style={{ height: 'calc(100vh - 120px)' }}>
          {/* Main Chat Area */}
          <div className="flex-1 flex flex-col justify-between h-full">
            <div className="flex-1 overflow-y-auto border rounded-lg p-4 mb-4 bg-white pb-16">
              {messages.map((message, index) => {
                const english = message.content.split(/\n+/)[0] || "";
                // AIãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å ´åˆã€AIãŒç™ºå£°ã—ãŸãƒ•ãƒ¬ãƒ¼ã‚ºï¼ˆæœ€åˆã®è‹±èªè¡Œï¼‰ã ã‘ã‚’è¡¨ç¤ºã—ã€èª¬æ˜æ–‡ã‚„è­¦å‘Šæ–‡ã¯ä¸€åˆ‡è¡¨ç¤ºã—ãªã„
                if (message.role === "assistant") {
                  // ä¸è¦ãªèª¬æ˜æ–‡ãƒ»è­¦å‘Šæ–‡ã‚’é™¤å¤–
                  if (
                    !english ||
                    english.startsWith("This input is in Japanese") ||
                    english.startsWith("It seems like the input is written in Japanese") ||
                    english.startsWith("I'm sorry") ||
                    english.startsWith("Sorry") ||
                    english.startsWith("Please provide") ||
                    english.startsWith("This text is already in Japanese") ||
                    english.startsWith("This input appears to be in Japanese")
                  ) {
                    return null;
                  }
                  // è¨³ï¼ˆ2è¡Œç›®ä»¥é™ï¼‰
                  const lines = message.content.split(/\n+/);
                  const japanese = lines.length > 1 ? lines.slice(1).join(' ').replace(/^(è¨³[:ï¼š]?|\[.*?\])/, '').trim() : '';
                  return (
                    <div key={index} className="flex mb-4 justify-start">
                      <div className="max-w-[80%] rounded-lg p-3 bg-muted">
                        <p className="text-sm font-bold">{english}</p>
                        {showTranslation && japanese && (
    <>
      {/* ä½¿ã„æ–¹ã‚¬ã‚¤ãƒ‰ã‚’ç”»é¢å³ä¸Šã«å›ºå®šè¡¨ç¤ºï¼ˆlgä»¥ä¸Šã§ã®ã¿è¡¨ç¤ºã€containerå¤–ï¼‰ */}
      <div className="hidden lg:block fixed top-24 left-0 z-30 w-[260px]">
        <div className="border border-blue-300 bg-blue-50 rounded-lg p-4 shadow-sm w-full ml-2">
          <div className="font-bold text-blue-700 mb-2 flex items-center gap-2">
            <span role='img' aria-label='info'>â„¹ï¸</span> {t('how_to_use_title')}
          </div>
          <div className="text-sm whitespace-pre-line text-blue-900">{t('how_to_use_body')}</div>
        </div>
      </div>
      <div className="flex w-full min-h-screen h-screen">
        {/* Main Chat Area */}
        <div className="flex-1 flex flex-col h-full">
          <div className="flex-1 overflow-y-auto border rounded-lg p-4 mb-4 bg-white pb-16">
            {messages.map((message, index) => {
              const english = message.content.split(/\n+/)[0] || "";
              // AIãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å ´åˆã€AIãŒç™ºå£°ã—ãŸãƒ•ãƒ¬ãƒ¼ã‚ºï¼ˆæœ€åˆã®è‹±èªè¡Œï¼‰ã ã‘ã‚’è¡¨ç¤ºã—ã€èª¬æ˜æ–‡ã‚„è­¦å‘Šæ–‡ã¯ä¸€åˆ‡è¡¨ç¤ºã—ãªã„
              if (message.role === "assistant") {
                // ä¸è¦ãªèª¬æ˜æ–‡ãƒ»è­¦å‘Šæ–‡ã‚’é™¤å¤–
                if (
                  !english ||
                  english.startsWith("This input is in Japanese") ||
                  english.startsWith("It seems like the input is written in Japanese") ||
                  english.startsWith("I'm sorry") ||
                  english.startsWith("Sorry") ||
                  english.startsWith("Please provide") ||
                  english.startsWith("This text is already in Japanese") ||
                  english.startsWith("This input appears to be in Japanese")
                ) {
                  return null;
                }
                // è¨³ï¼ˆ2è¡Œç›®ä»¥é™ï¼‰
                const lines = message.content.split(/\n+/);
                const japanese = lines.length > 1 ? lines.slice(1).join(' ').replace(/^(è¨³[:ï¼š]?|\[.*?\])/, '').trim() : '';
                return (
                  <div key={index} className="flex mb-4 justify-start">
                    <div className="max-w-[80%] rounded-lg p-3 bg-muted">
                      <p className="text-sm font-bold">{english}</p>
                      {showTranslation && japanese && (
                        <p className="text-sm mt-1 !text-white" style={{ color: '#fff' }}>{japanese}</p>
                      )}
                    </div>
                  </div>
                );
              } else {
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™ºè©±ã‚‚è¨³è¡¨ç¤ºå¯¾å¿œ
                const lines = message.content.split(/\n+/);
                const userEnglish = lines[0] || "";
                const userJapanese = lines.length > 1 ? lines.slice(1).join(' ').replace(/^(è¨³[:ï¼š]?|\[.*?\])/, '').trim() : '';
                return (
                  <div key={index} className="flex mb-4 justify-end">
                    <div className="max-w-[80%] rounded-lg p-3 bg-primary text-primary-foreground">
                      <p className="text-sm font-bold">{userEnglish}</p>
                      {showTranslation && userJapanese && (
                        <p className="text-sm mt-1 text-gray-100">{userJapanese}</p>
                      )}
                    </div>
                  </div>
                );
              }
            })}
            {isLoading && (
              <div className="flex justify-start mb-4">
                <div className="max-w-[80%] rounded-lg p-3 bg-muted">
                  <div className="flex space-x-2">
                    <div className="w-2 h-2 rounded-full bg-gray-400 animate-bounce" />
                    <div className="w-2 h-2 rounded-full bg-gray-400 animate-bounce [animation-delay:0.2s]" />
                    <div className="w-2 h-2 rounded-full bg-gray-400 animate-bounce [animation-delay:0.4s]" />
                  </div>
                </div>
              </div>
            )}
            
            <div ref={messagesEndRef} />
            {suggestedPhrases && (
              <div className="mt-4 p-3 border-l-4 border-blue-400 bg-blue-50 rounded">
                <div className="font-bold text-blue-700 mb-1">ğŸ’¡ãƒ•ãƒ¬ãƒ¼ã‚ºä¾‹ï¼ˆå›°ã£ãŸã¨ãã®ãƒ’ãƒ³ãƒˆï¼‰</div>
                <pre className="text-sm text-blue-900 whitespace-pre-wrap">{suggestedPhrases}</pre>
              </div>
            )}
          </div>

          {/* Input Area */}
          <div className="flex items-center gap-2 justify-center mt-4 flex-col">
            <button
              onClick={toggleRecording}
              className={`w-16 h-16 flex items-center justify-center rounded-full bg-primary text-white shadow-lg transition-colors duration-150 ${isRecording ? 'opacity-70' : 'hover:bg-primary/90'}`}
              style={{ fontSize: '2.5rem', outline: 'none', border: 'none' }}
              aria-label={isRecording ? 'Stop Recording' : 'Start Recording'}
            >
              {isRecording ? <MicOff className="h-10 w-10" /> : <Mic className="h-10 w-10" />}
            </button>
          </div>

          {/* Translation Toggle */}
          <div className="flex items-center mb-2">
            <button
              type="button"
              className={`mr-2 p-1 rounded-full ${showTranslation ? 'bg-accent text-accent-foreground' : 'bg-muted text-muted-foreground'}`}
              onClick={() => setShowTranslation((prev) => !prev)}
              title={showTranslation ? t('show_translation') : t('show_translation')}
            >
              <Lightbulb className="w-5 h-5" />
            </button>
            <span className="text-xs text-muted-foreground">{t('show_translation')}</span>
          </div>
        </div>

        {/* Sidebar */}
        <div className="w-[370px] h-full overflow-y-auto flex-shrink-0">
          {/* ãƒã‚¤ãƒ†ã‚£ãƒ–ãŒã‚ˆãä½¿ã†ãƒ•ãƒ¬ãƒ¼ã‚ºé›† */}
          <div className="border border-green-300 bg-green-50 rounded-lg p-4 shadow-sm w-full h-full">
            <div className="font-bold text-green-700 mb-2 flex items-center gap-2">
              <span role='img' aria-label='spark'>ğŸ’¬</span> {t('phrase_set_title')}
            </div>
            <Accordion type="multiple" className="w-full">
              {Object.entries(phraseSet).map(([categoryKey, phrases]) => (
                <AccordionItem value={categoryKey} key={categoryKey}>
                  <AccordionTrigger className="text-black">{t(`phrase_set_category_${categoryKey}`)}</AccordionTrigger>
                  <AccordionContent>
                    <ul className="mb-3 list-disc list-inside text-black">
                      {Array.isArray(phrases) && phrases.map((item, idx) => (
                        <li key={idx}>
                          {item.phrase} {item.translation && <span className="text-gray-500">ï¼ˆ{item.translation}ï¼‰</span>}
                        </li>
                      ))}
                    </ul>
                  </AccordionContent>
                </AccordionItem>
              ))}
            </Accordion>
          </div>
        </div>
      </div>
    </>
  )
}
